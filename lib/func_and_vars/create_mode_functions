#!/bin/bash

# Functions for create mode
# <start>
fav_text_editor() {
	TEXT_EDITOR_FILE=$SCRIPT_LOCATION/.fav_editor

	if [[ ! -f $TEXT_EDITOR_FILE ]]; then
		read -rp "$(echo -e "${GREEN}[*] ${CYAN}Enter the path/alias for your fav text editor:${WHITE} ")" TEXT_EDITOR
		echo "TEXT_EDITOR=$TEXT_EDITOR" >"$TEXT_EDITOR_FILE"
		echo -e "${GREEN}[+] ${BLUE}Setting $TEXT_EDITOR as your default text editor for this tool${WHITE}"
		source "$TEXT_EDITOR_FILE"
	else
		source "$TEXT_EDITOR_FILE"
		echo -e "${GREEN}[+] ${BLUE}Using ${GREEN}$TEXT_EDITOR${BLUE} as editor ${CYAN}[change in $SCRIPT_LOCATION/.fav_editor]${WHITE}"
	fi
}

create_config_file() {
	if [[ ! -f "$CONFIG_FILE_location" ]]; then
		echo -e "${GREEN}[+] ${BLUE}Creating configuration file${WHITE}"

		"$TEXT_EDITOR" "$CONFIG_FILE_location"
	else
		echo -e "${YELLOW}[-] ${BLUE}Configuration file already exists!${WHITE}"
	fi
}

create_git_folder() {
	if [[ ! -d "$GIT_MAIN_FOLDER_location" ]]; then
		echo -e "${GREEN}[+] ${BLUE}Creating local github folder${WHITE}"

		mkdir "$GIT_MAIN_FOLDER_location"
	else
		echo -e "${YELLOW}[-] ${BLUE}Local github folder already exists!${WHITE}"
	fi
}

create_remote_github_repo() {
	read -rp "$(echo -e "${GREEN}[*] ${CYAN}Do you want to create a new github repository or use already existing one? [new/existing]:${WHITE} ")" ANSWER

	if [[ $ANSWER == new ]]; then
		echo -e "${GREEN}[+] ${BLUE}Creating repository on github..${WHITE}"

		read -rp "$(echo -e "${GREEN}[*] ${CYAN}Enter the github repository name to be created and used ['owner/repo_name']:${WHITE} ")" NEW_ORIGIN
		read -rp "$(echo -e "${GREEN}[*] ${CYAN}Specify the visibility to set for repository [public/private]:${WHITE} ")" VISIBILITY

		gh repo create https://github.com/"$NEW_ORIGIN" --"$VISIBILITY" --description "Git repo for syncing $GIT_MAIN_FOLDER folder in real-time"
		git remote add origin https://github.com/"$NEW_ORIGIN"
	elif [[ $ANSWER == existing ]]; then
		echo -e "${YELLOW}[-] ${BLUE}Skipping the creation of remote repository on github${WHITE}"

		read -rp "$(echo -e "${GREEN}[*] ${CYAN}Enter already existing github repository name to be used ['owner/repo_name']:${WHITE} ")" EXISTING_ORIGIN
		echo -e "${GREEN}[+] ${BLUE}Using already existing github repository${WHITE}"

		git remote add origin https://github.com/"$EXISTING_ORIGIN"
	else
		cd "$CURRENT_LOCATION" || exit

		ERROR_invalid_input
	fi
}

initialise_git() {
	cd "$GIT_MAIN_FOLDER_location" || exit

	if [[ ! -d ".git" ]]; then
		echo -e "${GREEN}[+] ${BLUE}Initialising git in the github folder${WHITE}"
		read -rp "$(echo -e "${GREEN}[*] ${CYAN}Specify the name of branch you want to use particularly [default=main]:${WHITE} ")" BRANCH

		git init

		## Not using 'git branch -m main' OR 'git checkout -b main'
		## As either one of them might not work in different flavours of *nix
		## Far better to modify the HEAD file manually
		echo "ref: refs/heads/${BRANCH:=main}" >".git/HEAD"

		## Logic for github remote repo
		create_remote_github_repo
	else
		echo -e "${YELLOW}[-] ${BLUE}Git is already initialised in the github folder!${WHITE}"
		read -rp "$(echo -e "${GREEN}[*] ${CYAN}Specify the name of branch you want to use particularly [default=main]:${WHITE} ")" BRANCH

		## Not using 'git branch -m main' OR 'git checkout -b main'
		## As either one of them might not work in different flavours of *nix
		## Far better to modify the HEAD file manually
		echo "ref: refs/heads/${BRANCH:=main}" >".git/HEAD"

		## checking the existence of remote github repo in the .git folder
		echo -e "${GREEN}[+] ${BLUE}Checking for the existense of remote repo os 'origin'${WHITE}"
		REMOTE_TEST=$(git remote | grep origin >/dev/null && echo "69")

		if [[ $REMOTE_TEST != 69 ]]; then
			echo -e "${CYAN}[~] ${BLUE}Remote repo as 'origin' doesn't exist!${WHITE}"

			## Logic for github remote repo
			create_remote_github_repo
		elif [[ $REMOTE_TEST == 69 ]]; then
			echo -e "${CYAN}[~] ${BLUE}Remote repo as 'origin' exists!${WHITE}"
		fi
	fi

	cd "$CURRENT_LOCATION" || exit
}

create_readme() {
	cd "$GIT_MAIN_FOLDER_location" || exit

	if [[ ! -f "README.md" ]]; then
		echo -e "${GREEN}[+] ${BLUE}Creating README.md file in the github folder${WHITE}"

		echo "# Edit it" >README.md
		echo "This is sample README.md file, generated by gsync(author @proffapt)" >>README.md
		git add README.md
		git commit -m "inital commit for README.md via gsync tool by @proffapt"
	else
		echo -e "${YELLOW}[-] ${BLUE}README.md file already exists in the github folder!${WHITE}"
	fi

	cd "$CURRENT_LOCATION" || exit
}

move_config_to_git_folder() {
	if [[ ! -f "$new_CONFIG_FILE_LOCATION" ]]; then
		echo -e "${GREEN}[+] ${BLUE}Moving the configuration file to github folder${WHITE}"

		mv "$CONFIG_FILE_location" "$GIT_MAIN_FOLDER_location"

		cd "$GIT_MAIN_FOLDER_location" || exit
		git add "$CONFIG_FILE"
		git commit -m "initial commit for $CONFIG_FILE via gsync too by @proffapt"
		cd "$CURRENT_LOCATION" || exit
	else
		echo -e "${YELLOW}[-] ${BLUE}Configuration file already exist in the github folder!${WHITE}"
	fi
}

create_link_to_config() {
	if [[ ! -f "$CONFIG_FILE_location" ]]; then
		echo -e "${GREEN}[+] ${BLUE}Creating Configuration 'link file' from configuration file in github folder${WHITE}"

		ln -s "$new_CONFIG_FILE_LOCATION" "$CONFIG_FILE_location"
	else
		echo -e "${YELLOW}[-] ${BLUE}Configuration 'link file' already exists!${WHITE}"
	fi
}

configure_syncsript() {
	## Just making sure syncscript is executable
	if [[ ! -x $SYNC_SCRIPT_location ]]; then
		chmod +x "$SYNC_SCRIPT_location"
	fi

	if [[ ! -f $GSYNC_INIT ]]; then
		echo -e "${GREEN}[+] ${BLUE}Configuring syncscript${WHITE}"

		## create and initialise startup.sh for the very first successfull run
		if [[ ! -f $STARTUP_SCRIPT ]]; then
			cat <<- EOF > "$STARTUP_SCRIPT"
				#!/bin/bash
				
				## Separating every entry from this script
				set -m 
					
				## Entries for github folder to be synced continuously via the syncscript by gsync
			EOF

			chmod +x "$STARTUP_SCRIPT"
		fi
		## Creating logs folder if it doesn't exist already
		if [[ ! -d  $SCRIPT_LOCATION/lib/logs ]]; then
			mkdir "$SCRIPT_LOCATION"/lib/logs
		fi
		## adds the syncing command entry to that startup.sh file
		echo -e "${GREEN}[+] ${BLUE}Adding command entry to startup script${WHITE}"
		echo "nohup $SYNC_SCRIPT_location -d $GIT_MAIN_FOLDER_location > ${SCRIPT_LOCATION}/lib/logs/${GIT_MAIN_FOLDER}.log &" >> "$STARTUP_SCRIPT"

		## handling previously running instances of the entry if any
		PROCESS_COUNT=$(ps -ef | grep "$SYNC_SCRIPT_location -d $GIT_MAIN_FOLDER_location" | awk '{print $2}' | grep "^" -c)
		for ((i=$PROCESS_COUNT; i>1; i--))
		do
			PID=$(ps -ef | grep "$SYNC_SCRIPT_location -d $GIT_MAIN_FOLDER_location" | awk 'NR==1{print $2}')
			echo -e "${CYAN}>> ${WHITE}Terminating previously running instance(pid=$PID) of this entry"
			kill "$PID"
		done
		if [[ $PROCESS_COUNT == 1 ]]; then
			echo -e "${YELLOW}[-] ${BLUE}No running instance found for this entry${WHITE}"
		fi
		## executing the currently added entry
		## calling the recent entry alone is beneficial, rather than calling the startup script again and creating multiple
		## instances of other commands too
		nohup "$SYNC_SCRIPT_location" -d "$GIT_MAIN_FOLDER_location" > "$SCRIPT_LOCATION"/lib/logs/"$GIT_MAIN_FOLDER".log &

		## implementing logic for executing the startup script on every login
		if [[ $KERNEL == "Darwin" ]]; then
			## giving /bin/bash full disk access if not given already
			BINBASH_CHECK=$(sqlite3 /Library/Application\ Support/com.apple.TCC/TCC.db 'select client from access where auth_value and service = "kTCCServiceSystemPolicyAllFiles"' | grep -iq "/bin/bash" && echo 1)
			if [[ $BINBASH_CHECK != 1 ]]; then
				clear
				echo "${RED}[!] ${YELLOW}/bin/bash${CYAN} doesn't have ${YELLOW}Full Disk Access${CYAN} crucial for syncscript to start on login"
				echo "
				${RED}NOTE FROM THE DEVELOPER:${YELLOW}

				Now don't cry for the fact that this script is asking you to do some clicks.. saying it was supposed to be fully automated process.
				I can't help it, to automate the addition of this entry to FDA database via this script user needs to have SIP disabled,
				which is not suggested in general and for those who don't even know what the actual fuck it is, just forget it.

				This is a one time process, you won't be seeing this message again while using this script.. if you follow all the steps given below correctly.
				"
				echo "${GREEN}[+] ${BLUE}Follow the steps below to achieve the above task${WHITE}"

				## printing out required steps (can't automate requires SIP disabled by default)
				echo "
				${YELLOW}1.${WHITE} System Preferences ${CYAN}->${WHITE} Security & Privacy ${CYAN}->${WHITE} Privacy ${CYAN}->${WHITE} Full Disk Access
				${YELLOW}2.${WHITE} Click the '${GREEN}lock${WHITE}' in the lower left corner to allow changes
				${YELLOW}3.${WHITE} Click on '${GREEN}+${WHITE}' button to open finder window
				${YELLOW}4.${WHITE} Go to your ${ORANGE}root directory${WHITE} (named as Macintosh HD)
				${YELLOW}5.${WHITE} Press '${CYAN}Cmd+Shift+.${WHITE}' key combination to show hidden files
				${YELLOW}6.${WHITE} Go to ${ORANGE}bin${WHITE} folder and select ${ORANGE}bash${WHITE} inside it
				${YELLOW}7.${WHITE} Click '${GREEN}open${WHITE}' on the bottom right corner to choose bash
				${YELLOW}8.${WHITE} Close system Preferences.
				"
				read -rp "${CYAN}[^]${BLUE} Enter '${CYAN}proceed${BLUE}' to open System Preferences for you: ${WHITE}" PROCEED
				if [[ $PROCEED != "proceed" ]]; then
					echo "${RED}[!] ${WHITE}User denied to open System Preferences"
					_EXIT_
				else
					open -a "System Preferences"
					read -rp "${CYAN}[^]${BLUE} Enter '${CYAN}done${BLUE}' to proceed to next steps: ${WHITE}" DONE
					if [[ $DONE != "done" ]]; then
						echo "${RED}[!] ${WHITE}User did not complete the addition of ${YELLOW}/bin/bash${WHITE} to ${YELLOW}FDA database${WHITE}"
						_EXIT_
					fi
				fi
			fi


			if [[ ! -f ~/Library/LaunchAgents/com.gsync-startup.plist ]]; then
				## Method used for starting the startup.sh script on login: LaunchAgent
				cat <<- EOF > ~/Library/LaunchAgents/com.gsync-startup.plist
					<?xml version="1.0" encoding="UTF-8"?>
					<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
					<plist version="1.0">
					<dict>
						<key>KeepAlive</key>
						<dict>
							<key>Crashed</key>
							<true/>
							<key>SuccessfulExit</key>
							<false/>
						</dict>
						<key>Label</key>
						<string>com.gsyn-startup.app</string>
						<key>LimitLoadToSessionType</key>
						<string>Aqua</string>
						<key>ProgramArguments</key>
						<array>
							<string>/bin/bash</string>
							<string>$STARTUP_SCRIPT</string>
						</array>
						<key>RunAtLoad</key>
						<true/>
					</dict>
					</plist>
				EOF
			fi
		else
			## Method used for starting the startup.sh script on login: /etc/profile.d
			cp "$STARTUP_SCRIPT" /etc/profile.d/gsync-startup.sh
		fi

		## keeping track whether this folder is being used once or more than once
		cd "$GIT_MAIN_FOLDER_location" || exit 

		echo "The existense of this file signifies that gsync was ran atleast once on this folder." > .gsync_init
		echo ".gsync_init" >> .gitignore
		git add .gitignore
		git commit -m "initial commit for gitignore file via gsync tool by @proffapt"

		cd "$CURRENT_LOCATION" || exit

	else
		echo -e "${YELLOW}[-] ${BLUE}Syncscript already configured${WHITE}"
	fi
}

git_push() {
	echo -e "${GREEN}[+] ${BLUE}Pushing changes to github if any in the git folder${WHITE}"

	cd "$GIT_MAIN_FOLDER_location" || exit 
	git push --set-upstream origin $BRANCH
	cd "$CURRENT_LOCATION" || exit
}
# </start>
